'''
보수 : 보충해주는 수

n진법 수 x가 있을 때, 이 x에 더해서 n 의 최소 제곱수가 될 수 있도록 만드는 수를 x의 n의 보수

6에서 10의 최소 제곱수인 10으로 만들어 주는 수 => 4
4는 십진수 6의 10의 보수가 된다

보수 사용하는 이유??
컴퓨터에서 음수를 표현하기 위해 보수를 사용
컴퓨터는 사칙연산할 때 더하기만 사용가능 (뺄셈도 덧셈으로 계산)
 A - B = A + (-B)
 B의 보수를 구한 뒤에 더하기

이진법에서...
 음수를 표현하기 위해서 비트를 모두 반대로 바꿈
 1의 보수 => 어떤 수를 커다란 2의 거듭제곱수 -1 (모든 비트의 숫자가 1)에서 빼서 얻은 이진수

이진수 0101의 1의 보수 => 1111 - 0101 = 1010
    1111
  - 0101
   ------
    1010


1의 보수에서 0 은 0000000...
근데 이건 뒤집으면 1111111... 이것도 0
0을 두개로 표현 +0 -0
1의 보수는 0이 두개로 표현될 수 있다. ==> 불편함 발생

2의 보수 => 1의 보수를 구하고 1을 더하면 된다.
4비트
1 = 0001
-1 = 1111 - 0001 = 1110, 1110 + 1 = 1111

'''

# < 연습문제 1 > 33 p
'''
0 과 1로 이루어진 1차 배열에서 7개 byte 를 묶어서 10진수로 출력하기

00000010001101 ==> 1 13 출력
0000000111100000011000000111100110000110000111100111100111111001100111
==> 0 120 12 7 76 24 60 121 124 103 출력
'''
'''
arr = list(map(int, input()))
n = len(arr)
num = 0
for i in range(n):
    j = i % 7
    num += arr[i] * (2 ** (6 - j))
    if j == 6:  # 7개 끊기
        print(num, end=' ')
        num = 0
print()
'''

# < 연습문제 2 > 45 p
'''
16진수 문자로 이루어진 1차 배열, 앞에서부터 7 bit 씩 묶어 10진수로 변환
0F97A3
000011111001011110100011 => 0000111 1100101 1110100 011
7 101 116 3
'''
# < 신교수님 풀이>
'''
h1 = "0F97A3"

def solution(n):
    # n은 16진수 문자열
    # 16진수는 0~15까지 표현 가능 => 2진수로 0 0 0 0 : 4칸 필요
    # 길이 * 4 = 비트 수
    l = len(n) * 4
    # 16진수 문자열을 숫자로 바꾸기
    x = int(n, 16)
    # 결과문자열
    result = ""

    # 뒤에서부터 7개씩 잘라서 2진수 만든 뒤에 다시 10진수로 만들기
    for i in range(l - 1, -1, -7):
        # 현재 위치 i에서 7개 잘라서 만든 이진수
        bin = ""
        # x의 i-j번째 비트 판별
        for j in range(7):
            # ValueError: negative shift count 음수만큼 쉬프트가 일어났다 ==> 자리수가 넘어 갔다
            # 더 이상만들 필요 없으므로
            if i - j < 0:
                break
            bin += "1" if x & (1 << i - j) else "0"

        print(bin, end=" ")    # 0000111 1100101 1110100 011

        # 2진수인 bin 을 10진수로 바꾸기
        dec = int(bin, 2)
        result += str(dec) + " "
    print()
    print(result)    # 7 101 116 3

solution(h1)
'''
# < 라이브 교수님 풀이 >
'''
01D06079861D79F99F
'''
'''
arr = input()
for x in arr:
    num = int(x, 16)
    # print(int(x, 16), end = ' ')    # 0 1 13 0 6 0 7 9 8 6 1 13 7 9 15 9 9 15
    for j in range(3, -1, -1):
        bit = 1 if num & (1 << j) else 0
        print(bit, end='')
        # 000000011101000001100000011110011000011000011101011110011111100110011111
    print(' ', end='')
    # 0000 0001 1101 0000 0110 0000 0111 1001 1000 0110 0001 1101 0111 1001 1111 1001 1001 1111
'''
'''
x = 0x01020304
print(x) # 십진수 : 16909060
print(f'0{x:x}') # f-string : 01020304
print('0%X' % x) # %(modulo) - formatting : f-string 없었던 옛날 방식
'''


# < 연습문제 3 > 56p
# 16진수 문자로 이루어진 1차 배열, 암호 비트 패턴을 찾아 차례대로 출력하시오
# 16진수 -> 숫자 -> 이진수 -> 숫자 / 뒤에서부터 찾기

'''
0DEC
00 001101 111011 00 ==> 0 2 출력

입력 예 : 0269FAC9A0 ==>
'''

pat = {
    "001101" : 0,
    "010011" : 1,
    "111011" : 2,
    "110001" : 3,
    "100011" : 4,
    "110111" : 5,
    "001011" : 6,
    "111101" : 7,
    "011001" : 8,
    "101111" : 9
}

h1 = "0DEC"
h2 = "0269FAC9A0"

def find_pattern(n):
    # n은 16진수로 되어있는 문자열
    # 이진수로 바꾸면 길이 4배 증가
    l = len(n) * 4
    x = int(n, 16)
    print(l)
    # 이진수로 바꾸기
    bin = ""
    for i in range(l - 1, -1, -1):
        # i 번째 비트가 1인지 아닌지
        bin += "1" if x & (1 << i) else "0"
    # 뒤에서부터 검사 해서 1을 만나면 암호 해독
    # 암호 해독한 후에 결과
    res = []

    bin = list(bin)
    print(bin)

    # 뒤에서부터 검사, 패턴 길이가 6이니까 뒤에서부터 왔을 때 앞에 최소 5개(index 로는 6)가 있어야함
    for i in range(l - 1, 5, -1):
        # 1을 만난 순간 6개씩 잘라서 검사
        if bin[i] == "0":
            continue

        # 6개 슬라이싱
        code = bin[i:i - 6:-1]

        # 뒤집기
        code = code[::-1]

        # 문자열로 만들기
        code_str = "".join(code)

        # 사전에서 찾기
        dec = pat.get(code_str)

        # 사전 안에 패턴이 존재하는 경우 => 10진수
        print(dec, code_str)
        if dec != None:
            res.append(dec)
            # 남은 5칸에서 또 패턴을 찾지 않도록 0으로 바꿔준다.
            for j in range(i, i - 6, -1):
                bin[j] = "0"
    print(res[::-1])
find_pattern(h1)
find_pattern(h2)


# 암호코드 스캔 <과제>

# 문자열 그대로 사전에 등록해두기 보다는 비율을 등록하기 ex) (3:2:1:1) : 0
t = int(input())
for tc in range(1, t+1):





















