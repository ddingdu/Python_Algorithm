< 버블 정렬 >
- 코딩이 가장 쉽다 / 비교와 교환
- 첫 원소를 기준으로 인접한 원소와 비교해서 자리 교환
- 첫 자리부터 가장 마지막 자리까지 이동
- 첫 원소를 최대나 최소로 가정 후 인접한 원소와 비교해서 값 바꿔주기
- 큰 원소를 오른쪽으로 옮기기

for i : n-1 -> 1
    for j: 0 -> i-1 # 비교할 왼쪽 원소 ( 0 인덱스부터 i-1 인덱스 )
        if arr[j] > arr[j+1]
            arr[j]  <-> arr[j+1] # 큰 원소를 오른쪽으로 옮기기

< 카운팅 정렬 >
- n 이 비교적 작을 때만 가능하다 / 비교환 방식
- 항목들의 순서를 정하기 위해 각 항목이 몇 개씩 있는지 세고 정렬
- 정수나 정수로 표현할 수 있는 자료(고유 번호를 부일 수 있는) 만 적용 가능
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수(k)를 알아야함
    ( cnt = [0] * k ) k = 정수의 최대 값
- 누적합 이용 counts[i] = counts[i-1] + counts[i]

< 선택 정렬 >
- 교환의 회수가 버블 정렬보다 작다 / 비교와 교환
- 주어진 자료 중 가장 작은 값 원소부터 차례대로 선택하여 위치 교환
- 오른차순 기준 1. 최소값 찾기 2. 최소 값과 리스트 맨 앞 값을 교환 3. (n - 1)까지 반복

